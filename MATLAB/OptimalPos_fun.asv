import dsp
import cvxpy as cp
import numpy as np
import matplotlib.pyplot as plt

def OptimalPos(
    p_pa2: np.ndarray,
    p_na2: np.ndarray,
    p_p2: np.ndarray,
    p_n2: np.ndarray,
    p_p4: np.ndarray,
    p_n4: np.ndarray,
    A_pa2: np.ndarray,
    A_na2: np.ndarray,
    A_p2: np.ndarray,
    A_n2: np.ndarray,
    A_p4: np.ndarray,
    A_n4: np.ndarray,
    B_p: np.ndarray,
    p_p0: np.ndarray,
    B_n: np.ndarray,
    p_n0: np.ndarray,
    M: np.ndarray,
    lamp: np.ndarray,
    lamn: np.ndarray,
    Phi_u: np.ndarray,
    Phi_l: np.ndarray,
    x2: np.ndarray,
    N: float,
    K: float,
    C: float,
    theta: float = 0.25,
    alpha: float = 1.2,
    ):
    
    N = int(N)
    K = int(K)
    C = int(C)

    P = np.diag(A_p4*p_p4 + A_n4*p_n4)
    
    M = np.transpose(M)

    y = cp.Variable(K)
    zp = cp.Variable(N)
    zn = cp.Variable(N)
    
    f = dsp.inner( zp-zn, P @ ( M @ y ) )
    f1 = (p_p2+p_n2) @ (M @ y)
    rho = A_pa2*p_pa2 @ cp.multiply(theta, cp.power(zp+zn,alpha)) \
            + A_na2*p_na2 @ cp.multiply(theta,cp.power(zp+zn,alpha))
    
    constraints = [z >= 0]
    for i in range(C): #range(len(a)):
        constraints.append(B_p*p_p0 @ cp.maximum(x2 @ (zp-zn)-(lamp[i]-1),0) <= Phi_u[i])
        constraints.append(B_n*p_n0 @ cp.maximum((lamn[i]-1)-x2 @ (zp-zn),0) <= -Phi_l[i])

    obj = dsp.MinimizeMaximize(rho+f+f1)
    prob = dsp.SaddlePointProblem(obj, constraints)
    prob.solve()  # solves the problem

    print(prob.value)
    return y.value

z = OptimalPos(p_pa2,p_na2,p_p2,p_n2,p_p4,p_n4,
               A_pa2,A_na2,
    A_p2,
    A_n2,
    A_p4,
    A_n4,
    B_p,
    p_p0,
    B_n,
    p_n0,
    M,
    lamp,
    lamn,
    Phi_u,
    Phi_l,
    x2,
    N,
    K,
    C,
    theta,
    alpha,
    )
